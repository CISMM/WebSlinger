# Project Description

Our goal in this project was to simulate a flexible object in real time and to provide force feedback based on the simulation.  The fact that we wanted the simulation to run in real time dictated that we should have a model that was quick to compute, which in turn implied that we model a one- dimensional flexible object such as a rubber band.  We also wanted to provide things besides the rubber band in the environment with which the user could interact.  For these objects we chose room walls, a free mass that could be picked up and tossed about, and another mass that swings back and forth in the world in simple harmonic motion.  See figure 1 for a picture of the environment.

The flexible rubber band is modelled as a series of masses connected by springs.  Each spring applies force to the masses at its end points, and the motion of the mass between two springs transmits the force from one spring to the next on the list.  In this was we have information about the forces acting on each point mass within the rubber band and we have a mechanism by which the movement of one mass in the rubber band will cause all of the others to follow because of the forces exerted by the interconnecting springs.

In our model, the user interacts with the environment by manipulating one end of the rubber band.  This is done by means of the Argonne-III Remote Manipulator (ARM) that is located in the graphics lab.  We made the mass at one end of the rubber band track along with the motions of the ARM hand grip, thus allowing the user to move the rubber band around in three dimensions.  We also transmitted the forces that would be felt at the end mass to the user via the servo motors in the ARM.  The end result is that the user sees and feels the effects of moving the end mass on the rubber band.  The user can interact with the other masses in the environment by grabbing onto them with the mass at the far end of the rubber band (the end that is not controlled directly by the ARM.)  When the finger trigger is held down on the hand grip, the far mass will be tied to any mass that it passes through.  When the trigger is released, any mass that is held will be released and will continue on with its current velocity.

The graphic display in our model shows a chain of spheres, with one centered at each point mass.  The springs connecting the spheres are not shown in our model.  There are also spheres representing the ball that can be tossed and the ball in simple harmonic motion.  Color differentiates these balls from each other and from the balls that make up the rubber band.  The room walls are also shown to demarcate the boundaries of our working volume.  The display is done on the Pixel-Planes 4 graphic processor and can be displayed on the BARCOdata projector screen directly in front of the ARM.

Our model also provides for real time control of the gravity in the simulation, the viscosity of the medium in which the masses move, the amount of movement in world space a given ARM movement will produce, the magnitude of the forces that will be felt by the user, the maximum distance the user can be from an object when it is grabbed, and the time step over which the simulation is performed.  All of these parameters are varied by using six resistor pots that are mounted on the lower part of the ARM, just above the hand grip.  This allows the user to feel the effects of many different configurations and to compare them in real time.  It also allows a user to study the effects of time step and viscosity on the stability of this type of simulation.

# How the modelling is done

Movable objects in our environment are modelled as a group of masses, any two of which may be connected by one or more springs.  The simulation proceeds be first computing all of the forces acting on each mass and then by moving all of the masses over a time interval assuming that the forces remain constant over that interval.

The masses in the environment are stored in a linked list.  This structure allows for a flexible number of objects in the environment while still allowing a linear time traversal of the lists each time the positions are to be updated or displayed.  Each node in the mass list stores the mass of the point, the location of the point, the velocity of the point, and the forces that are currently acting on the point.  The mass nodes also store the damping of velocity that should apply to each point.  This is related to the viscosity of the medium in which the masses travel.  The forces that are applied to each mass accumulate in the current force location and are cleared when the position update is performed on all of the masses.

The springs that connect the masses are also stored in a list.  Each spring node hold the value of the spring constant for the spring, the rest length of the spring, and pointers to the masses located at each end of the spring.  The pointers allow quick access to the position and force information that is stored in the masses connected to a given spring.  This allows computation of the forces applied by all springs in time that is proportional only to the number of springs in the environment.  See figure 2 for a depiction of the spring list and the mass list.

The first step in the simulation of flexible objects is the building of the objects to be modelled.  Our modelling routines provide a function that will return a string of masses tied together by springs such that each spring is at rest length and the masses all lie in a straight line in space.  This function is called make_string() and it is used by our simulation to create the rubber band.  The other two masses in the environment are created by the use of the function add_mass(), which will place a new mass onto the mass list without adding spring connections to masses already in the list.  Another spring is added to the spring list via add_spring().  This is the spring that will be used to tie the far end of the rubber band to one of the other masses in the environment.  It is initially tied with both ends on the same mass and a rest length of zero.  This means that it will not generate forces.  When we want to tie the end mass on the rubber band to another mass, one of the pointers in this spring is set to each mass.  When the new mass is released, the pointers are set to both point to the same mass.

The main simulation loop for the program involves updating the forces that are to act on each mass in the environment, having those forces act on the objects, and then clearing the forces and repeating.  The forces due to the springs in the environment are applied by calling the function apply_springs() and giving it a pointer to the spring list.  This function will traverse the list of springs and send the forces applied by each of them to the masses tied at each end.  The forces applied by the walls are computed by assuming that the walls act as springs and push any mass entering them back out again by exerting a force perpendicular to their surface.

Once the forces exerted by the springs and the walls have accumulated in the masses, the simulation over a time step is performed by the function step_masses().  This function is passed a pointer to the mass list, an acceleration (such as gravity) that is to be applied to all masses on the list, and the time step over which to simulate movement.  The forces and accelerations acting on the masses are assumed to be constant over the time step.  This routine passes through the mass list and does the following for each mass.  A damping force is added to the mass based on its initial velocity in the time step.  The acceleration of the mass is then found based on the forces and accelerations acting on it.  The new position for the mass is found based on the average velocity, and the final velocity is found based on the acceleration and initial velocity.  Lastly, the forces on the mass are cleared so that they can accumulate again during the next time step.

The modelling code also provides for hinges, which act on triples of masses and tend to keep the center one on the line between the other two, but this was not implemented in our demonstration because it reduced the flexibility of the string and because the added forces tended to make the model unstable at a smaller time step.

# How the arm is tied in

The arm is used to move the mass at one end of the rubber band by setting the position and velocity of the end mass to match that of the arm at the beginning of each simulation loop.  The other masses in the string follow along because they are pulled by the springs connecting the other masses to the head mass.

The forces applied by the springs and by the walls are computed as described above, and then the forces on the head mass are read and transmitted to the user through the function Send_Handgrip_Forces(), which is provided by the ARM library code.  The forces on that mass are then set to zero so that the simulation code will not attempt to move the mass over the next time step.  In this way the user can feel the same forces that they would if they were actually holding on to the head mass in the rubber band.  Forces from the other masses in the rubber band are transmitted by the spring from the head mass to the second, and forces from the walls are also felt.

# Files used in the modelling

The file massmesh.h contains the definitions of the constants and types that are used in the simulation, as well as declaring the functions that can be called to perform the simulation steps.  The file massmesh.c contains the code that actually performs the simulation.  The file armstring.c has the main routine that ties together the use of the ARM, the pxpl4 display, and the simulation into one package.
